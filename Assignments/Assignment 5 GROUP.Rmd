---
title: "Assignment 5"
author: "Eva Wilson"
date: "3/8/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# attach packages 
library(here)
library(purrr)
library(tidyverse)
library(testthat)
```

## Assignment Instructions 

Design a function - you can pick any subject and you can even make up the equations as long as they conceptually make sense
  X Make sure it has at least 2 inputs and 1 parameter (ideally more) and at least 2 outputs
  X Code your function in R, save as a R file in subdirectory called R
  X Make sure you include documentation (both at the top as we’ve shown in past examples, and inline)
  X Include some error checking

In an Rmarkdown file, generate some data for 2 of the function inputs
  Use a for loop to run the function for the data
  Repeat the “looping” using something from the “purrr” package
  Graph results (you can decide what the most interesting way to graph - you just need to make one graph)

X Write at least 2 tests for your function; store in a separate test file

Put this in a git repo that includes an R subdirectory a tests subsdirectory and an Rmarkdown file and submit the link on Gauchospace (or you can put all of this in a new git repo or a subdirectory of an existing git repo)

## Step 1. Source function 
```{r}
source(here("R/irrigation.R"))
```

## Step 2. List assumptions 

1. **Precipitation:** We assume that precipitation is normally distributed. The mean precipitation is 2.5 mm/day with a standard deviation of 1 mm/day. 

2. **ET:** We assume that average ET for wheat is 2.04 mm/day, corn is 2.54 mm/day, and barley is 3.00 mm/day. 

3. **Possible Crops:** There are 50 fields in our analysis that are subject to the same rainfall. We assume each occurs equally (we use random sample).

## Step 3. Create data frames to test functionality
```{r}
# create vector of crop type
possible_crop = c("wheat","corn","barley")
# use sample to simulate a random recording of fields for analysis
possible_crop = base::sample(possible_crop, size=50, replace=T)
# possible.crop as a factor for better plotting
possible_crop = as.factor(possible_crop)
# to quickly get frequencies of different crops and to plot 
summary(possible_crop)
plot(possible_crop, col="blue")

# specify base ET (mm/day) (see assumptions)
evapotranspiration = case_when((possible_crop == 'wheat') ~ 2.04,
                                (possible_crop == 'corn') ~ 2.54,
                                (possible_crop == 'barley') ~ 3.00)

# generate a normal distribution of random precipitation data
# note that 10 mm converts to 0.394 inches.  
precipitation <- rnorm(50, mean = 2.5, sd = 1)
# view the first 10 values of the precipitation data
head(precipitation, 10)
# quickly visualize to see distribution
plot(density(precipitation))

# combine generated data into a single frame  called irrigation summary 
irrigation_summary = cbind.data.frame(possible_crop, evapotranspiration, precipitation)
# change first column name to "crop name"
colnames(irrigation_summary)[1] <- "crop_name"
irrigation_summary
```

(Example for another method of creating dataframe):
```{r}
### after creating sample of crops and making them vectors,
### turn that vector list into a dataframe
irrigation_df <- as.data.frame(possible_crop) %>%
  ## change col name
  rename(crop_type = possible_crop)
  

### Now add ET and precip into our df using dplyr::mutate()
irrigation_df <- irrigation_df %>% 
  ## create column for ET and specify values based on `crop_type`
  mutate(ET = case_when((crop_type == 'wheat') ~ 2.04,
                        (crop_type == 'corn') ~ 2.54,
                        (crop_type == 'barley') ~ 3.00)) %>% 
  ## create precip values into new column
  mutate(precipitation = rnorm(50, mean = 2.5, sd = 1))


### Finally, add empty columns for whether to irrigate
### and how much. These will get filled by pmap in next step.
irrigation_df <- irrigation_df %>% 
  add_column(should_irrigate = NA,
             irrigation_amt_L = NA)

### NOTE: maybe don't create these columns before running pmap?
### potentially make this a part of the fxn....
```


```{r}
### test fxn
# irrigation(ET = irrigation_df$ET[2],
#            precip = irrigation_df$precipitation[2],
#            crop_type = irrigation_df$crop_type[2])


### need to fix the return to make sure it fills columns correctly
```


# Step 4. Use the *pmap* loop to run the function for the data 
```{r}
# pmap runs a function for each value in a list of parameters, with other parameters set for each iteration

# CLASS EXAMPLE" powerall2 = pmap(list(A = possible_cars$area, m=possible_cars$mass), autopower, V=speeds)

# lets turn to a data frame for easier graphing
# we can add column names
# CLASS EXAMPLE powerall2 = as.data.frame(powerall2, col.names=possible_cars$name)

# soil moisture availability output and amount output

knitr::include_graphics(here("brainstorm_irrigation.png"))
```

# Step 5. Graph results (KATHERYN)
```{r}
# we can plot the soil moisture availability and facet_wrap by crop_type 
# ggplot(data = , aes(x=, y=)+
       # geom_histogram(stat="count")+
         #labs()
```

# Step 6. Run two tests to make sure this function is working (KATHERYN)
```{r}
# source data
here("irrigation.R")
# put your test in a file
# LET ME KNOW IF YOU HAVE PROBLEMS ACCESSING THIS? I JUST CREATED TWO BASIC FUNCTION TESTS USING EXPECT_EQUAL
#test_file(here("irrigation_works.R"))
```
